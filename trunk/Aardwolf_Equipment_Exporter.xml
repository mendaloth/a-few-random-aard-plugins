<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Saturday, October 30, 2010, 11:20 AM -->
<!-- MuClient version 4.61 -->

<!-- Plugin "Aardwolf_Equipment_Exporter" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Aardwolf_Equipment_Exporter"
   author="Mendaloth"
   id="036a5673859577cb131b6912"
   language="Lua"
   purpose="Exports Your equipment to a CSV File"
   save_state="y"
   date_written="2010-10-30 11:19:47"
   requires="3.74"
   version="1.07">
<description trim="n"><![CDATA[
--------------------------------------------------------------------------------
Aardwolf Equipment Exporter 1.07  Help

         Simple Commands

exporter help           - Displays this information page.
exporter all            - Captures all information from your bags, inventory,
                          and worn equipment automatically. Warning this takes
                          a few minutes, as it takes each item out of your bags one by
                          one.  
						
         Options Below Can Used to Capture Only a Portion of Equipment
                                				
exporter <bagid>        - Will export the equipment from the bag with <bagid>.
                          You can find the id by typing "id keyword" (where the
                          bag's keyword is a keyword from the bag). It will be
                          a big number on the line below the Name.
exporter inv            - Will export the equipment in your inventory, but not
                          in a bag
exporter worn           - Will export the equipment you are currently wearing.
exporter clear          - Will clear any equipment data currently imported.
                          Nothing is saved between sessions, this is only used
                          if you want to start over in the same MUSHClient session.
exporter export         - Exports the information to a file when done capturing.

        Just a simple utility function Used by the Plugin's Author
		
exporter portals        - Put portals in the portal bag.
]]></description>
</plugin>

<!--  Get our standard constants -->
<include name="constants.lua"/>


<!--  Triggers  -->
<triggers>
<trigger
   match="^{invdetails}$"
   enabled="n"
   regexp="y"
   expand_variables="y"
   keep_evaluating="y"
   group="capture_inv_details"
   send_to="12"
   sequence="100">
  <send>
    EnableTrigger ("capture_all_inv_details", true)
  </send>
</trigger>

<trigger
   match="^.*$"
   enabled="n"
   regexp="y"
   omit_from_output="y"
   keep_evaluating="n"
   name="capture_all_inv_details"
   script="get_invdetails_lines"
   sequence="115">
</trigger>

<trigger
   match="^{/invdetails}$"
   enabled="n"
   regexp="y"
   expand_variables="y"
   omit_from_output="y"
   group="capture_inv_details"
   send_to="12"
   sequence="100">
  <send>
    EnableTrigger ("capture_all_inv_details", false)
    EnableTriggerGroup("capture_inv_details", false)
	
    if Get_Next_Item_Without_All_Item_Data() == nil then
		info_gathered = true
		if (capturing_all) then
			if (capturing_all_step == 0) then
				Note("Done Capturing your worn equipment.  Now capturing equipment in your inventory.")
				bag_id = "inventory"
				Get_Inv_Data("")
				capturing_all_step = 1
			elseif (capturing_all_step == 1) then
				EnableTrigger("capture_bag_info_tag", true)
				SendNoEcho("echo {capture_next_bag_info}")
			end
		else
			Note("Done gathering the equipment data.  You can export it to a file with the 'exporter export' command, or capture equipment data from other bags, worn, inventory etc.")
		end
	else
		Get_Next_Equipment_Item_Data()
	end
  </send>
</trigger>

<trigger
   match="^{invdata(?: \d+)?}$"
   enabled="n"
   regexp="y"
   omit_from_output="y"
   keep_evaluating="n"
   name="inv_data_open_tag"
   send_to="12"
   sequence="115">
  <send>
    EnableTrigger("capture_all_inv_data", true)
    EnableTrigger("inv_data_close_tag", true)
  </send>
</trigger>

<trigger
   match="^{eqdata}$"
   enabled="n"
   regexp="y"
   omit_from_output="y"
   keep_evaluating="n"
   name="eq_data_open_tag"
   send_to="12"
   sequence="115"
  >
  <send>
    EnableTrigger("capture_all_inv_data", true)
    EnableTrigger("eq_data_close_tag", true)
  </send>
</trigger>

<trigger
   match="^{capture_next_bag_info}$"
   enabled="n"
   regexp="y"
   omit_from_output="y"
   keep_evaluating="n"
   name="capture_bag_info_tag"
   send_to="12"
   sequence="115"
  >
  <send> 
	for key, value in pairs(equipment) do
		if (value.itemtype == "Container" and value.item_container_captured == false) then
			value.item_container_captured = true
			Note("Now capturing data for equipment within a level " .. value.level .. " contained named '".. value.name .."' with Objectid " ..value.objectid .. ".")
			bag_id = tostring(value.objectid)
			Get_Inv_Data(tostring(value.objectid))			
			return
		end
	end
	-- If you've reached this point then all containers  have been captured.
	capturing_all_step = 3
	capturing_all = false
	EnableTrigger("capture_bag_info_tag", false)
	Note("All your equipment has been captured.")
	Save_File()
  </send>
</trigger>

<trigger
   match="^.*$"
   enabled="n"
   regexp="y"
   omit_from_output="y"
   keep_evaluating="n"
   name="capture_all_inv_data"
   script="get_invdata_lines"
   sequence="115">
</trigger>

<trigger
   match="^{/eqdata}$"
   enabled="n"
   regexp="y"
   omit_from_output="y"
   keep_evaluating="n"
   name="eq_data_close_tag"
   send_to="12"
   sequence="1">
  <send>
    EnableTrigger("capture_all_inv_data", false)
    EnableTrigger("eq_data_close_tag", false)
    EnableTrigger("eq_data_open_tag", false)
    Fill_Equipment_Data()
  </send>
</trigger>

<trigger
   match="^{/invdata}$"
   enabled="n"
   regexp="y"
   omit_from_output="y"
   keep_evaluating="n"
   name="inv_data_close_tag"
   send_to="12"
   sequence="1">
  <send>
    EnableTrigger("capture_all_inv_data", false)
    EnableTrigger("inv_data_close_tag", false)
    EnableTrigger("inv_data_open_tag", false)
    Fill_Equipment_Data()
  </send>
</trigger>
</triggers>


<!--  Aliases  -->
<aliases>
<alias
   match="exporter *"
   enabled="y"
   echo_alias="y"
   send_to="12"
   sequence="100">
  <send>
    if "%1" == "help" then
      Note(GetPluginInfo(GetPluginID(), 3))
    elseif "%1" == "export" then
      Save_File()
    elseif "%1" == "worn" then
      bag_id = "worn"
      Get_Worn_Data()
    elseif "%1" == "inv" then
      bag_id = "inventory"
      Get_Inv_Data("")
	elseif "%1" == "clear" then
	   equipment = {}
	   info_gathered = false  
    elseif "%1" == "portals" then
		local bag_id = utils.inputbox ("What is the keyword or objectid for the bag you wish to place the portals in?", "Query")
		if (bag_id == nil) then
			Note("Putting portals into the bag was cancelled.")
			return
		end
		Put_Portals_In_Portal_Bag(bag_id)
	elseif "%1" == "all" then
		Capture_All_Inventory_Info()
	elseif "%1" == "exportww" then
      Save_File_WW()
	    --Undocumented feature which is works alongside
        --which works alongside Winkle's equipment plugin
	else
      bag_id = "%1"
      Get_Inv_Data("%1")
    end
  </send>
</alias>  
</aliases>


<!--  Script  -->
<script><![CDATA[

require "tprint"
equipment = {}
info_gathered = false
capturing_all = false

function Get_Inv_Data(bagid)
  EnableTrigger("inv_data_open_tag", true)
  SendNoEcho(("invdata %s ansi"):format(bagid))
end

function Get_Worn_Data()
  EnableTrigger("eq_data_open_tag", true)
  SendNoEcho("eqdata ansi")
end


function get_invdata_lines(_, line)
  local data = utils.split(line, ",")
  
  if (data[5] == "19" or data[5] == "8") then -- the item is a potion or pill don't need to capture details just fill in dummy values
	--For potions/pill don't need to do a invdetails.  Most players have a lot of them and it would be slow
	--so mark details_captured as true to stop invdetails from being captured
	--and fill in some dummy values.
	equipment[data[1]] = {
		objectid = data[1],
		name = data[3],
		level = data[4],
		weight = "",
		container_id = bag_id,
		itemtype = "Potion/Pill",
		resists = {},
		stats = {},
		details_captured = true,
		score = "0",
		flags = "",
		wearloc = "",	
	}
  else
	equipment[data[1]] = {
		objectid = data[1],
		name = data[3],
		container_id = bag_id,
		resists = {},
		stats = {},
		details_captured = false,
	}
  end
  
end

function Put_Portals_In_Portal_Bag(portal_bag_id)
	local num_portals = 0
	for key, value in pairs(equipment) do
    if (value.wearloc == "hold, portal") then
		num_portals = num_portals + 1
		Send("put " .. value.objectid .. " " .. portal_bag_id)
	end
  end
  Note("Number of portals found was: "..num_portals)
end

function Get_Inv_Details(object_id)
  EnableTriggerGroup("capture_inv_details", true)
  SendNoEcho(("invdetails %s"):format(object_id))
end

function Get_Next_Item_Without_All_Item_Data()
  -- the equipment array can hold data from equipment that has
  -- already been imported and equipment that hasn't been imported
  -- So this function will return the next item that hasn't had it's invdetails
  -- data captured
  for key, value in pairs(equipment) do
    if not value.details_captured then
      return value.objectid -- index will be nil, the beginning
    end    
  end
end

function Get_Next_Equipment_Item_Data()
  current_equipment_objectid = Get_Next_Item_Without_All_Item_Data()
  
  if (current_equipment_objectid == nil) then
	Note("There were no items inside that bag.") 
	if (capturing_all) then -- this hack is needed if in the middle of capturing all bags.
		  EnableTriggerGroup("capture_inv_details", true)
		  SendNoEcho("echo {/invdetails}") -- simulate the end of the bag
	end
	return
  end
  
  local o = equipment[current_equipment_objectid]
  o.details_captured = true
  
  if o.container_id == "inventory" or o.container_id == "worn" then
    Note(o.name .. " added.")
    Get_Inv_Details(current_equipment_objectid)
  else
	SendNoEcho(("get %s %s"):format(o.objectid, o.container_id))
	Get_Inv_Details(current_equipment_objectid)
	SendNoEcho(("put %s %s"):format(o.objectid, o.container_id))
  end
  
  --{invheader}43573447|91|Armor|11060|0|wrist|unique
end

function Fill_Equipment_Data()
  current_equipment_objectid = nil
  Get_Next_Equipment_Item_Data()
end



function Get_Tag_Data(line)
  local e = string.find (line, "}")
  if not e then
    return "", line
  else
    return line:sub(2, e-1), line:sub(e+1)
  end
end

function get_invdetails_lines(_, line)
  local tag, data = Get_Tag_Data(line)
  data = utils.split(data, "|")

  local o = equipment[current_equipment_objectid]
  
  if tag == "statmod" then
    -- Data is in this format Hit points|10
    o.stats[data[1]:gsub(" ", ""):lower()] = tonumber(data[2])
  elseif tag == "resistmod" then
    -- Data is in this format Hit points|10
    o.resists[data[1]:gsub(" ", ""):lower()] = tonumber(data[2])
  elseif tag == "invheader" then
    -- header lines are stored in this format objectid|level|itemtype|value|weight|wearloc|flags|owner|
    -- fromclanname|timer|||itemscore
    o.objectid = data[1]
    o.level            = tonumber(data[2])
    o.itemtype = data[3]
    o.weight   = tonumber(data[5])
    o.wearloc  = string.lower(data[6])
    o.flags    = data[7]
    o.owner    = data[8]
    o.score    = data[14]
	o.item_container_captured = false --default value, used when capturing all data automatically
  elseif tag == "weapon" then
    o.weapon_data = {
      type        = data[1],
      avg_dam     = data[2],
      damage_type = data[3],
      specials    = data[5],
    }
  end
end


function Get_Resists_Text(resists_array)
  local t = {}
  for key, value in pairs(resists_array) do
    table.insert(t, ("%s:%s"):format(key, value))
  end

  local resists_text = table.concat(t, ",")
  return resists_text ~= "" and resists_text or "None"
end

function csvstring(x)
  x = tostring(x)
  if x:match(",") or x:match('"') then
    return ("%q"):format(x)
  else
    return x
  end
end

function Get_Equipment_Line(item)
  local buf = {
    insert = function(t, s) table.insert(t, csvstring(tostring(s))) end,
    concat = table.concat,
  }
  
  buf:insert(item.name)
  buf:insert(item.level)
  buf:insert(item.itemtype)
  buf:insert(item.wearloc)
  buf:insert(item.weight)
  buf:insert(item.objectid)
  buf:insert(item.stats.wisdom or 0)
  buf:insert(item.stats.intelligence or 0)
  buf:insert(item.stats.luck or 0)
  buf:insert(item.stats.constitution or 0)
  buf:insert(item.stats.strength or 0)
  buf:insert(item.stats.dexterity or 0)
  buf:insert(item.stats.damageroll or 0)
  buf:insert(item.stats.hitroll or 0)
  buf:insert(item.stats.mana or 0)
  buf:insert(item.stats.hitpoints or 0)
  buf:insert(item.stats.saves or 0)
  buf:insert(item.stats.moves or 0)
  buf:insert(item.score)
  buf:insert(item.flags)
  buf:insert(item.owner ~= "" and item.owner or "None")
  buf:insert(Get_Resists_Text(item.resists))
  
  if item.wearloc == "wield" then
    local weapon = item.weapon_data
    buf:insert(weapon.type)
    buf:insert(weapon.avg_dam)
    buf:insert(weapon.damage_type)
    buf:insert(weapon.specials)
  else
    buf:insert("N/A")
    buf:insert("N/A")
    buf:insert("N/A")
    buf:insert("N/A")
  end
  
  buf:insert(item.container_id)
  
  return buf:concat(",")
end

local file_header = table.concat({
    "Item Name", "Level", "Item Type", "Wear Location", "Weight", "Id", "Wis", "Int", "Luck", "Con", "Str", "Dex",
    "DR", "HR", "Mana", "Hit Points", "Saves", "Moves", "Score", "Flags", "Owner", "Resists",
    "Weapon Type", "Avg Damage", "Damage Type", "Weapon Specials", "Container",
  },
  ","
)
function Save_File()
  if not info_gathered then
    Note("You must first get the equipment data using the 'exporter <bagid>' command.")
    return
  end
  
  local filename = utils.filepicker("Save as",
                                    "Equipment_exported",
                                    "csv",
                                    {csv = "CSV files", ["*"] = "All files"},
                                    true)
  if not filename then
    Note("No file name entered")
    return
  end
  
  Note("The filename is " .. filename)
  
  f = io.output (filename)
  f:write(file_header, "\n")
  
  for key, value in pairs(equipment) do
    f:write(Get_Equipment_Line(value), "\n")
  end
  
  f:close()
end

function Capture_All_Inventory_Info()
	-- clear any previously captured equipment
	equipment = {}  
	info_gathered = false
	capturing_all = true
	capturing_all_step = 0

	Note("Capturing your worn equipment.")
	bag_id = "worn"
	Get_Worn_Data()
end
function Save_File_WW()
  --Undocumented feature which is works alongside
  --which works alongside Winkle's equipment plugin
  if not info_gathered then
    Note("You must first get the equipment data using the 'exporter <bagid>' command.")
    return
  end
  
  local filename = utils.filepicker("Save as",
                                    "Equipment_exported_WW",
                                    "txt",
                                    {txt = "Text files", ["*"] = "All files"},
                                    true)
  if not filename then
    Note("No file name entered")
    return
  end

	-- sort in level order
	local by_level = {}
	for key, value in pairs(equipment) do
		if (value.wearloc ~= "") then
			if (by_level[value.level] == nil) then
				by_level[value.level] = {}
			end
			by_level[value.level][#by_level[value.level]+1] = value		
		end
	end
  
  Note("The filename is " .. filename)
  
	f = io.output (filename)

	local level = 0
	for level = 1, 300 do
	local lvalue = by_level[level]
	
		if (lvalue ~= nil) then
		
			f:write("equip_inv['" .. level .. "'] = {\n")

			for ikey, ivalue in pairs(lvalue) do		
				local bag = ""
				if (ivalue.container_id ~= "inventory") then
					bag = "bag_" .. ivalue.container_id
				end
				
				local wearloc = ivalue.wearloc
				
				wearloc = string.gsub(wearloc, "finger", "rfinger, lfinger")
				wearloc = string.gsub(wearloc, "ear", "rear, lear")
				wearloc = string.gsub(wearloc, "wrist", "rwrist, lwrist")
				wearloc = string.gsub(wearloc, "neck", "neck1, neck2")
				wearloc = string.gsub(wearloc, "medal", "medal1, medal2, medal 3, medal4")
				wearloc = string.gsub(wearloc, "wield", "wield, second")								

				f:write(string.format("\t%s = { name = '%s', bag = '%s', replaces=''}, -- %s\n",
					wearloc,
					ivalue.objectid,
					bag,
					ivalue.name))
			end	--inside for
			
			f:write("}\n\n")
		end --if	
	
	end --loop
  
	f:close()
end
]]></script>

</muclient>