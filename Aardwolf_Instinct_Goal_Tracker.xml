<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Wednesday, August 06, 2008, 1:13 PM -->
<!-- MuClient version 4.35 -->

<!-- Plugin "Consider_info" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Aardwolf_Instinct_Goal_Tracker"
   author="Mendaloth"
   id="3285bd222a6f0afedf48d44e"
   language="Lua"
   purpose="Tracks your progress towards goals for instinct."
   date_written="2008-10-15 07:35"
   requires="4.30"
   version="1.0"
   save_state="y"
   >
<description trim="y">
<![CDATA[
Aardwolf Instinct Goal Tracker Tracker v 1.0

<=================== ACTIONS ===================>
instinct help                   --> Displays this message.                                 
instinct refresh                --> Refreshes how many of each instinct you have bought
                                  > by checking 'instinct all'.
instinct goal <instinct>        --> Displays the current goal for <instinct>.
instinct endgoal                --> Shows your progress towards your end goal for every
                                  > instinct.
instinct nextgoal               --> Shows your progress towards the next unreached goal for
                                  > every instinct.

<=================== Settings ===================>							  						  
instinct addgoal <instinct> <goal>
instinct delgoal <instinct> <goal>
				
]]>
</description>

</plugin>


<!--  Triggers  -->

<triggers>

	<trigger
	enabled="y"
	expand_variables="y"
	match="^You spend (.*?) trains and (.*?) gold to increase your (.*?) instinct to (.*?).$"
	regexp="y"
	send_to="12"
	sequence="5"
	>
		<send>
			local skillname = "%3"
			local instinct_amount = tonumber("%4")
			
			Update_Instinct(skillname, instinct_amount)
			
			--it should always exist so don't need to check key	
			--and yes I know Update_Instinct calls this function too, but 
			--made that function before this trigger and figure best to 
			--keep updating in one function call!
			local instinct_exists_key = Instinct_Exists(skillname)
			Note("Your " .. instinct[instinct_exists_key].skillname .. " instinct has been updated to " .. instinct[instinct_exists_key].instinct_bought .. ".")
		</send>
	</trigger>
</triggers>

<aliases>	  
 <alias
   match="instinct help"
   enabled="y"
   echo_alias="y"
   send_to="12"
   sequence="101">
  <send>
    Note(GetPluginInfo(GetPluginID(), 3))
	Note(" -- end Mendaloth's Instinct Goal Tracker Help File ---")
	Note(" -- Display the Mudside instinct help file ---") 	
	SendNoEcho("instinct help") --The mud side help file should be displayed as well.
  </send>
</alias> 


 <alias
   match="instinct debug"
   enabled="y"
   echo_alias="y"
   send_to="12"
   sequence="101">
  <send>
    tprint (instinct)
  </send>
</alias> 

 <alias
   match="instinct endgoal"
   enabled="y"
   echo_alias="y"
   send_to="12"
   sequence="101">
  <send>
    Overall_Report()
  </send>
</alias> 

 <alias
   match="instinct nextgoal"
   enabled="y"
   echo_alias="y"
   send_to="12"
   sequence="101">
  <send>
    Next_Goal_Report()
  </send>
</alias> 


 <alias
   match="instinct refresh"
   enabled="y"
   echo_alias="y"
   send_to="12"
   sequence="101">
  <send>
    Refresh_Instinct_Amounts()
  </send>
</alias> 

<alias
   match="^instinct goal (.*?)$"
   regexp = "y"
   enabled="y"
   echo_alias="y"
   send_to="12"
   sequence="95">
  <send>
		local is_instinct = Instinct_Exists("%1")
		local temp_gold_cost, temp_train_cost, total_instincts_to_buy = 0
		if (is_instinct) then
			--is instinct returns the key of the instinct so can just use that to display it.
			Display_Instinct_Goal(instinct[is_instinct]['skillname'], instinct[is_instinct]['instinct_bought'], instinct[is_instinct]['goals'])
			
			
			if (#instinct[is_instinct]['goals'] ~= 0) then
				if (instinct[is_instinct]['instinct_bought'] &lt;= instinct[is_instinct]['goals'][#instinct[is_instinct]['goals']]) then
					total_instincts_to_buy = instinct[is_instinct]['goals'][#instinct[is_instinct]['goals']] -  instinct[is_instinct]['instinct_bought']
				end
				temp_gold_cost, temp_train_cost = Get_Goal_Costs(instinct[is_instinct]['instinct_bought'], instinct[is_instinct]['goals'][#instinct[is_instinct]['goals']])
			else
				Note("No goals set for " .. instinct[is_instinct]['skillname'] .. " see 'instinct help' for how to set your instinct goals.")
			end
			
			if (temp_gold_cost ~= 0) then
				--if this is zero then no goals were set or they've already been reached.
				temp_text = "@R[@C " .. total_instincts_to_buy .. " away from Goal of " .. instinct[is_instinct]['goals'][#instinct[is_instinct]['goals']] .. " " .. instinct[is_instinct]['skillname'] .. " instinct @R] "
				temp_text = temp_text .. "@RTrains @W" .. Shrink_Number(temp_train_cost) .. "@D (@RRoughly @W" .. Shrink_Number(temp_train_cost/trains_per_pup) .. " @Rpups@D) |"
				temp_text = temp_text .. " @RGold @W" .. Shrink_Number(temp_gold_cost) .. "@D |"
				ColourTell_Styles(temp_text)
			end
		else
			Note("There is no instinct named '%1'.")
		end
	
  </send>
</alias>  

<alias
   match="^instinct addgoal (.*?) (\d*?)$"
   regexp = "y"
   enabled="y"
   echo_alias="y"
   send_to="12"
   sequence="95">
  <send>
	
	local is_instinct = Instinct_Exists("%1")
	if (is_instinct) then
		--check if the goal already exists.
		for key, value in pairs(instinct[is_instinct]['goals']) do
			if (value == tonumber("%2")) then
				Note("Instinct '%1' already has a goal of %2.")
				return
			end
		end
		-- it does not exist so add it
		table.insert(instinct[is_instinct]['goals'],  tonumber("%2"))
		-- now reorder the goals to keep the highest last.
		table.sort (instinct[is_instinct]['goals'])	
		Note("Goal of '%2' has been added to the instinct '%1'.")
		SaveState()
	else
		Note("There is no instinct named '%1'.")
	end

  </send>
</alias>  

<alias
   match="^instinct delgoal (.*?) (\d*?)$"
   regexp = "y"
   enabled="y"
   echo_alias="y"
   send_to="12"
   sequence="95">
  <send>
	local is_instinct = Instinct_Exists("%1")
	if (is_instinct) then
		--check if the goal already exists.
		for key, value in pairs(instinct[is_instinct]['goals']) do
			if (value == tonumber("%2")) then
				table.remove(instinct[is_instinct]['goals'], key)
				Note("The goal of %2 has been removed from the instinct '%1'.")
				SaveState()
				return
			end
		end
		-- it does not exist so can't very well delete it
		Note("The goal of %2 was not found in instinct '%1'.")
	else
		--No instinct name
		Note("There is no instinct named '%1'.")
	end
	
  </send>
</alias>  


</aliases>
<!--  Script  -->


<script>
<![CDATA[

require "serialize"
require "tprint"

-- functions for handling Aardwolf color codes
-- required to send use ColoursToStyles
dofile(GetInfo (66) .. "\\worlds\\plugins\\" .. "aardwolf_colors.lua")

trains_per_pup = 5 --eventually maybe have user set this?

function OnPluginSaveState ()
	SetVariable ("instinct", serialize.save ("instinct"))
end -- function OnPluginSaveState

function OnPluginInstall ()	
	instinct = {}
	
	assert (loadstring (GetVariable ("instinct") or "")) ()
end

function Done_Instinct_Capture()
	Note("Your instincts have been updated.")
	SaveState()
end

function Get_Gold_Cost_Single_Instinct(number)
	if (number <= 0) then
		return 0
	else
		return 1900000 + (number * 100000)
	end
end

function Get_Train_Cost_Single_Instinct(number)
	if (number <= 0) then
		return 0
	else
		return 175 + (25 * number)
	end
end

function Get_Goal_Costs(starting_point, ending_point)
	local gold_costs = 0
	local train_costs = 0
	
	--don't actually  need to buy your starting point, you buy the next one after it!
	for i=starting_point+1, ending_point do	
		gold_costs = gold_costs + Get_Gold_Cost_Single_Instinct(i)
		train_costs = train_costs + Get_Train_Cost_Single_Instinct(i)
--print("Amount " .. i .. " Gold: " ..  Get_Gold_Cost_Single_Instinct(i) .. " Train costs: " ..  Get_Train_Cost_Single_Instinct(i))
	end
	--print("Total to go from " .. starting_point .. " instinct to " .. ending_point .." instinct is - Gold:" .. gold_costs .. " Total Train costs: " .. train_costs)
	return gold_costs, train_costs
end

function Capture_Between_Tags(start_tag, end_tag, send_to_function, omit_from_output_val, regex_val, one_shot_val, function_to_call_at_end_tag, value_to_pass_to_function) 
-- Mendaloth's utlility function Capture_Between_Tags ver 1.01
-- omit_from_output is optional, defaults to false
-- regex is optional, defaults to false, and you must supply omit_from_output in order to use it
-- oneshot is optional, defaults to false, and you must supply omit_from_output and regex in order to use it
-- added function_to_call_at_end_tag, and value_to_pass_to_function both optional
	
	require "addxml"

	if (omit_from_output_val == nil) then
		omit_from_output_val = false
	end
	

	if (regex_val == nil) then
		regex_val = false
	end
	
	if (one_shot_val == nil) then
		one_shot_val = false
	end

	local unique_id = GetUniqueNumber()
	
	--Open tag trigger
	addxml.trigger {  match = start_tag, 
			regexp = regex_val,
			enabled = true,
			one_shot = one_shot_val,
			sequence = 50,
			omit_from_output = omit_from_output_val,
			name = "starting_tag"..unique_id,
			send_to = 12,
			send = "EnableTrigger('ending_tag'.."..unique_id..", true)	EnableTrigger('capture_all'.." .. unique_id .. ", true)"
		  }

	if (function_to_call_at_end_tag == nil) then
		function_to_call_at_end_tag = ""
	else
		if (value_to_pass_to_function == nil) then
			function_to_call_at_end_tag = " " .. function_to_call_at_end_tag .. "()"
		else
			function_to_call_at_end_tag = " " .. function_to_call_at_end_tag .. "(" .. value_to_pass_to_function .. ")"
		end
	end
	
	addxml.trigger {  match = end_tag, 
			regexp = regex_val,
			enabled = false,
			one_shot = one_shot_val,
			omit_from_output = omit_from_output_val,
			name = "ending_tag"..unique_id,
			sequence = 5,
			send_to = 12,
			send = "EnableTrigger('ending_tag'.."..unique_id..", false)	EnableTrigger('capture_all'.." .. unique_id .. ", false)" .. function_to_call_at_end_tag
		  }
		  
	addxml.trigger {     match="^.*$",
		regexp = true,
		enabled = false,
		omit_from_output = omit_from_output_val,
		sequence = 50,
		keep_evaluating=false,
		name = "capture_all"..unique_id,
		script = send_to_function
	}
		  
end



function trim(s)
  return (s:gsub("^%s*(.-)%s*$", "%1"))
end

function Refresh_Instinct_Amounts()
	Capture_Between_Tags("                                                   ---- Next Cost ----", "You have * available for instinct.", "Process_Instinct_Line", true, false, true, "Done_Instinct_Capture") 
	SendNoEcho("instinct all")
end

function Process_Instinct_Line(_, line, _, _)
	--Note("Line is " .. line)
	if (string.sub(line, 1, 1) == "-" or trim(line) == "") then
		--It's a blank line or filled with -, do nothing.
	else
		skill_name = trim(string.sub(line, 11, (11+22)))
		if (skill_name == "Skill name") then
			--This is the first line so just ignore it.
			return
		end
		instinct_amount = tonumber(trim(string.sub(line, 42, (42+8))))
		
		Update_Instinct(skill_name, instinct_amount)
	end
end

function Update_Instinct(skill, amount_bought)
	instinct_exists_key = Instinct_Exists(skill)
		
	if (instinct_exists_key) then
		--Note("instinct amount updated")
		
		instinct[instinct_exists_key].instinct_bought = amount_bought
	else
		--The instinct does not exist so create a blank one.
		--Note("Instinct created.")
		table.insert(instinct,  {skillname = skill, instinct_bought=amount_bought, goals={}})
	end	
end

function Instinct_Exists(instinct_name)
	-- If the instinct exists
	-- returns the key of the instinct.\
	-- otherwise returns false
	for key, value in pairs(instinct) do
		--Note("Comparing '" .. string.upper(value['skillname']) .. "' and '" .. string.upper(instinct_name) .. "'")
		if (string.upper(value['skillname']) == string.upper(instinct_name)) then
			--Note("We ahve a match the instinct key is " .. key)
			return key
		else
			--Note("No match")
		end
	end
	return false
end

function In_List(list, string_to_find)
	for key, value in pairs(list) do
		if (value == string_to_find) then
			return true
		end
	end
	return false
end

function Overall_Report(group_talk)
	--Go through each instinct
	--figure out how high it has to go in order to reach the end goal
	--save that in the instincts table
	local total_gold_cost = 0
	local total_train_cost = 0
	local total_instincts_to_buy = 0
		
	for instinct_key, instinct_value in pairs(instinct) do

		Display_Instinct_Goal(instinct_value['skillname'], instinct_value['instinct_bought'], instinct_value['goals'])
		
		if (#instinct_value['goals'] ~= 0) then
			if (instinct_value['instinct_bought'] <= instinct_value['goals'][#instinct_value['goals']]) then
				total_instincts_to_buy = total_instincts_to_buy + (instinct_value['goals'][#instinct_value['goals']] - instinct_value['instinct_bought'])
			end
			
			local temp_gold_cost, temp_train_cost = Get_Goal_Costs(instinct_value['instinct_bought'], instinct_value['goals'][#instinct_value['goals']])
			total_gold_cost = total_gold_cost + temp_gold_cost
			total_train_cost = total_train_cost + temp_train_cost
			
		end
	end	
	Note("Total")
	temp_text = "@R[@C" .. total_instincts_to_buy .." Points of Instinct@R] "
	temp_text = temp_text .. "@RTrains @W" .. Shrink_Number(total_train_cost) .. "@D (@RRoughly @W" .. Shrink_Number(total_train_cost/trains_per_pup) .. " @Rpups@D) |"
	temp_text = temp_text .. " @RGold @W" .. Shrink_Number(total_gold_cost) .. "@D |"
	ColourTell_Styles(temp_text)
	--tell mendaloth @R[@C155 Instinct@R] @RTrains @W400.95K@D @D(@RRoughly @W297.4@R pups@D)@w | @RGold @W4.37B@D 
end

function Next_Goal_Report()
	--Go through each instinct
	--figure out how high it has to go in order to reach the next goal
	--save that in the instincts table
	local total_gold_cost = 0
	local total_train_cost = 0
	local total_instincts_to_buy = 0
		
	for instinct_key, instinct_value in pairs(instinct) do

		Display_Instinct_Goal(instinct_value['skillname'], instinct_value['instinct_bought'], instinct_value['goals'], true)
		
		--need to figure out which is the first goal that hasn't been reached....
		local keep_going = true --we stop once we have found the first goal that hasn't been reached, this keeps track
		                        --resets for each instinct
		if (#instinct_value['goals'] ~= 0) then
			for goal_key, goal_value in pairs(instinct_value['goals']) do
				local temp_gold_cost, temp_train_cost = Get_Goal_Costs(instinct_value['instinct_bought'], goal_value)
			
				if (temp_gold_cost ~= 0 and keep_going) then
					total_gold_cost = total_gold_cost + temp_gold_cost
					total_train_cost = total_train_cost + temp_train_cost
					total_instincts_to_buy = total_instincts_to_buy + (goal_value - instinct_value['instinct_bought'])
					keep_going = false
				end
			end
		end
	end

	Note("Total")
	temp_text = "@R[@C" .. total_instincts_to_buy .." Points of Instinct@R] "
	temp_text = temp_text .. "@RTrains @W" .. Shrink_Number(total_train_cost) .. "@D (@RRoughly @W" .. Shrink_Number(total_train_cost/trains_per_pup) .. " @Rpups@D) |"
	temp_text = temp_text .. " @RGold @W" .. Shrink_Number(total_gold_cost) .. "@D |"
	ColourTell_Styles(temp_text)
	--tell mendaloth @R[@C155 Instinct@R] @RTrains @W400.95K@D @D(@RRoughly @W297.4@R pups@D)@w | @RGold @W4.37B@D 
end

function Display_Instinct_Goal(instinct_name, currently_bought, goal_table, display_only_first)
	if (display_only_first == nil) then
		--Didn't supply a value, default to doing nothing
		display_only_first = false
	end
		if (#goal_table == 0) then
			--do nothing the user hasn't even set up a goal for this instinct
			return
		end

		--Don't need a table when the highest goal is less than amount already bought
		if (currently_bought >= goal_table[#goal_table]) then
			Note("You have reached your instinct goal for " .. instinct_name .. "!")
			return
		end
		
		local sep =    "+----+----------+----------+"
		local labels = "|Goal|Trains    |Gold      |"
		
		Note("")		
		Note(instinct_name .. " : " .. currently_bought)
		Note(sep)
		Note(labels)
		
		local keep_displaying = true
		
		for goal_key, goal_value in pairs(goal_table) do
			local temp_gold_cost, temp_train_cost = Get_Goal_Costs(currently_bought, goal_value)
			
			if (temp_gold_cost ~= 0 and keep_displaying) then
				Note(sep)
				Note(string.format("|%4.4s|%10.10s|%10.10s|", goal_value, Shrink_Number(temp_train_cost), Shrink_Number(temp_gold_cost)))
				if (display_only_first == true) then
					--we have displayed one
					--and we are only supposed to delay the first
					--so stop displaying more
					keep_displaying = false
				end
			end
			
		end
		Note(sep)
		Note("")
end

function Return_Capped_Amount_If_Over_Cap(amount, cap)
	--When tracking categories goals vs already bought
	--never want to add more to already bought than
	--the amount that is the current goal.
	if (amount > cap) then
		return cap
	else
		return amount
	end
end

function Shrink_Number(number)
	if (number > 1000000000) then 
		--Billions
		number = number/1000000000
		return string.format("%.2fB", number)
	elseif (number > 1000000) then
		--millions
		number = number/1000000
		return string.format("%.2fM", number)
	elseif (number > 1000) then
		--thousands
		number = number/1000
		return string.format("%.2fK", number)
	else
		return number
	end
end


function ColourTell_Styles(aard_color_coded_text)
	styles = ColoursToStyles (aard_color_coded_text)
		
	for _, v in ipairs (styles) do
		--Borrowed this code from here: http://www.gammon.com.au/forum/bbshowpost.php?bbsubject_id=9713
		--it takes the styles and converts into colourtells to display in the main window
		 ColourTell (RGBColourToName (v.textcolour),
						RGBColourToName (v.backcolour),
						v.text)
	end -- for each style run
	Note("") -- needed to make a new line
end
]]>
</script>

</muclient>